name: Test Docker Build Workflow

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  build-image:
    permissions:
      contents: read
      packages: write
    uses: ./.github/workflows/build_image.yml
    with:
      branch: ${{ github.ref }}
      image_name: ${{ github.repository_owner }}/wescale_ci_image
      tags: test-${{ github.sha }}
      registry: ghcr.io
      platforms: linux/arm64/v8
  test-cluster:
    needs: build-image
    runs-on: macos-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: brew install kubectl

      - name: Install Docker CLI
        run: brew install docker

      - name: Install Colima
        run: |
          brew install colima
          LIMACTL_PATH=$(brew --prefix)/bin/limactl
          sudo curl -L -o $LIMACTL_PATH https://github.com/mikekazakov/lima-nohvf/raw/master/limactl && sudo chmod +x $LIMACTL_PATH

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Start Colima with Kubernetes
        run: |
          if ! colima start --kubernetes --network-address --arch arm64 --vm-type=qemu; then
            echo "Failed to start Colima"
            colima status
            exit 1
          fi

          MAX_ATTEMPTS=20
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if docker info > /dev/null 2>&1 && kubectl cluster-info > /dev/null 2>&1; then
              echo "✅ Docker and Kubernetes are running"
              break
            fi
            echo "Waiting for Docker and Kubernetes to start (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "❌ Timeout waiting for Docker and Kubernetes"
            docker info || true
            kubectl cluster-info || true
            exit 1
          fi

      - name: Verify Kubernetes is running
        run: |
          kubectl get nodes
          kubectl get pods -A

      - name: Verify and pull test image
        id: verify-image
        run: |
          IMAGE="ghcr.io/${{ github.repository_owner }}/wescale_ci_image"
          TAG="test-${{ github.sha }}"

          echo "Waiting for image to be available..."
          MAX_ATTEMPTS=12
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if docker pull $IMAGE:$TAG; then
              echo "✅ Successfully pulled image"
              docker images | grep wescale
              exit 0
            fi
            echo "Attempt $i/$MAX_ATTEMPTS: Image not yet available, waiting..."
            sleep 10
          done

          echo "❌ Failed to pull image after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Get Yaml Template
        uses: actions/checkout@v3
        with:
          repository: wesql/deploy
          path: './deploy'

      - name: Init yaml
        run: |
          TAG="test-${{ github.sha }}"
          IMAGE=${{ github.repository_owner }}/wescale_ci_image
          brew install sed
          sed "s/WESCALE_CI_IMAGE_NAME/$IMAGE/g; s/WESCALE_CI_IMAGE_TAG/$TAG/g" ./deploy/artifact/wescale-ci-template.yaml > ./wescale_cluster.yaml
          echo "$(cat ./wescale_cluster.yaml)"

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-2

      - name: Create S3 Bucket
        id: create_bucket
        run: |
          BUCKET_NAME="wescale-$(date +'%Y%m%d%H%M%S')"
          echo "Bucket name: $BUCKET_NAME"
          aws s3 mb s3://$BUCKET_NAME
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

      - name: Create ConfigMap and Secret in Kubernetes
        run: |
          export WESQL_OBJECTSTORE_BUCKET=${{ steps.create_bucket.outputs.bucket_name }}
          export WESQL_OBJECTSTORE_REGION=us-east-2
          export WESQL_OBJECTSTORE_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY_ID }}
          export WESQL_OBJECTSTORE_SECRET_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}

          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: wesql-server-config
          data:
            MYSQL_CUSTOM_CONFIG: |
              [mysqld]
              objectstore_provider=aws
              objectstore_region=${WESQL_OBJECTSTORE_REGION}
              objectstore_bucket=${WESQL_OBJECTSTORE_BUCKET}
              repo_objectstore_id=sysbench
              branch_objectstore_id=main
              datadir=/data/mysql/data
              log-error=/data/mysql/log/mysqld-error.log
              log-bin=binlog
              gtid_mode=ON
              enforce_gtid_consistency=ON
              log_slave_updates=ON
              binlog_format=ROW
              skip_name_resolve=ON
          EOF

          kubectl create secret generic wesql-server-secret \
          --namespace default \
          --type Opaque \
          --from-literal=WESQL_OBJECTSTORE_ACCESS_KEY=${WESQL_OBJECTSTORE_ACCESS_KEY} \
          --from-literal=WESQL_OBJECTSTORE_SECRET_KEY=${WESQL_OBJECTSTORE_SECRET_KEY} \
          --from-literal=MYSQL_ROOT_PASSWORD=passwd

      - name: Generate Cluster YAML File And Create Cluster
        run: |
          kubectl apply -f ./wescale_cluster.yaml

      - name: Wait for WeSQL Server to be ready
        run: |
          kubectl wait --for=condition=available deployment/wesql-vtgate --timeout=3000s
          kubectl exec -it $(kubectl get pods -l app.kubernetes.io/name=wesql-vtgate -o jsonpath='{.items[0].metadata.name}') -- mysql -uroot -P15306 -ppasswd -e "SHOW DATABASES;"

      - name: Clean up
        if: always()
        run: |
          kubectl delete -f ./wescale_cluster.yaml
          echo "Deleting bucket: ${{ steps.create_bucket.outputs.bucket_name }}"
          aws s3 rm s3://${{ steps.create_bucket.outputs.bucket_name }} --recursive
          aws s3 rb s3://${{ steps.create_bucket.outputs.bucket_name }}
