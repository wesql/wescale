/*
Copyright ApeCloud, Inc.
Licensed under the Apache v2(found in the LICENSE file in the root directory).
*/

package mysql

import (
	"context"
	"crypto/subtle"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	querypb "vitess.io/vitess/go/vt/proto/query"
	"vitess.io/vitess/go/vt/proto/topodata"
	"vitess.io/vitess/go/vt/vttablet/queryservice"
)

const (
	mysqlAuthServerMysqlBaseReloadInterval = 5 * time.Second
)

// AuthServerMysqlBase implements AuthServer using a static configuration.
type AuthServerMysqlBase struct {
	methods []AuthMethod
	// This mutex helps us prevent data races between the multiple updates of entries.
	mu sync.Mutex
	// This mutex helps us prevent data races between the multiple updates of cacheEntries.
	cacheLatch     sync.Mutex
	reloadInterval time.Duration
	// entries contains the users, passwords and user data.
	queryservice.QueryService
	entries      map[string][]*AuthServerMysqlBaseEntry
	cacheEntries map[string]*AuthServerMysqlBaseEntry
	sigChan      chan os.Signal
	ticker       *time.Ticker
}

var instance *AuthServerMysqlBase
var once sync.Once

func GetAuthServerMysqlBase() *AuthServerMysqlBase {
	once.Do(func() {
		instance = NewAuthServerMysqlBase()
	})
	return instance
}

// AuthServerMysqlBaseEntry stores the values for a given user.
type AuthServerMysqlBaseEntry struct {
	MysqlCachingSha2Password string
	// MysqlNativePassword is generated by password hashing methods in MySQL.
	// These changes are illustrated by changes in the result from the PASSWORD() function
	// that computes password hash values and in the structure of the user table where passwords are stored.
	// mysql> SELECT PASSWORD('mypass');
	// +-------------------------------------------+
	// | PASSWORD('mypass')                        |
	// +-------------------------------------------+
	// | *6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4 |
	// +-------------------------------------------+
	// MysqlNativePassword's format looks like "*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4", it store a hashing value.
	// Use MysqlNativePassword in auth config, maybe more secure. After all, it is cryptographic storage.
	MysqlNativePassword string
	ScramblePassword    []byte
	Password            string
	UserData            string
	plugin              string
	SourceHost          string
	Groups              []string
}

func NewAuthServerMysqlBase() *AuthServerMysqlBase {
	a := &AuthServerMysqlBase{
		entries:        make(map[string][]*AuthServerMysqlBaseEntry),
		cacheEntries:   make(map[string]*AuthServerMysqlBaseEntry),
		reloadInterval: mysqlAuthServerMysqlBaseReloadInterval,
	}
	a.methods = []AuthMethod{NewMysqlNativeAuthMethod(a, a)}
	a.methods = append(a.methods, NewSha2CachingAuthMethod(a, a, a))

	RegisterAuthServer("MysqlBase", a)
	a.installSignalHandlers()
	return a
}

func (a *AuthServerMysqlBase) installSignalHandlers() {
	a.sigChan = make(chan os.Signal, 1)
	signal.Notify(a.sigChan, syscall.SIGHUP)
	go func() {
		for range a.sigChan {
			a.reLoadUser()
		}
	}()

	// If duration is set, it will reload configuration every interval
	if a.reloadInterval > 0 {
		a.ticker = time.NewTicker(a.reloadInterval)
		go func() {
			for range a.ticker.C {
				a.sigChan <- syscall.SIGHUP
			}
		}()
	}
}

func (a *AuthServerMysqlBase) deleteUserFromCache(user string) {
	a.cacheLatch.Lock()
	defer a.cacheLatch.Unlock()
	delete(a.cacheEntries, user)
}
func (a *AuthServerMysqlBase) addUserToCache(user string, entry *AuthServerMysqlBaseEntry) {
	a.cacheLatch.Lock()
	defer a.cacheLatch.Unlock()
	a.cacheEntries[user] = entry

}

// reLoadUser load user information from mysql.user
func (a *AuthServerMysqlBase) reLoadUser() error {
	if a.QueryService == nil {
		return nil
	}
	ctx := context.Background()
	target := &querypb.Target{
		TabletType: topodata.TabletType_PRIMARY,
	}
	qr, err := a.QueryService.Execute(ctx, target, FetchUser, nil, 0, 0, nil)
	entries := make(map[string][]*AuthServerMysqlBaseEntry)
	for _, rows := range qr.Rows {
		user := rows[0].ToString()
		plugin := rows[1].ToString()
		authenticationString := rows[2].ToString()

		entrie := AuthServerMysqlBaseEntry{
			MysqlCachingSha2Password: authenticationString,
			MysqlNativePassword:      authenticationString,
			plugin:                   plugin,
		}
		entries[user] = append(entries[user], &entrie)
	}
	a.mu.Lock()
	a.entries = entries
	a.mu.Unlock()
	if err != nil {
		return err
	}
	return nil
}

func (a *AuthServerMysqlBase) SetQueryService(conn queryservice.QueryService) {
	a.QueryService = conn
}

// AuthMethods returns the AuthMethod instances this auth server can handle.
func (a *AuthServerMysqlBase) AuthMethods() []AuthMethod {
	return a.methods
}

// HandleUser is part of the Validator interface. We
// handle any user here since we don't check up front.
func (a *AuthServerMysqlBase) HandleUser(user string, plugin string) bool {
	if a.entries[user] == nil {
		return false
	}
	for _, entry := range a.entries[user] {
		if entry.plugin == plugin {
			return true
		}
	}
	return false
}

// DefaultAuthMethodDescription returns the default auth method in the handshake which
// is CachingSha2Password for this auth server.
func (a *AuthServerMysqlBase) DefaultAuthMethodDescription() AuthMethodDescription {
	return CachingSha2Password
}
func (a *AuthServerMysqlBase) UserEntryWithCacheHash(conn *Conn, salt []byte, user string, authResponse []byte, remoteAddr net.Addr) (Getter, CacheState, error) {
	a.cacheLatch.Lock()
	entry, ok := a.cacheEntries[user]
	a.cacheLatch.Unlock()
	if !ok {
		return &StaticUserData{}, AuthNeedMoreData, nil
	}
	// Validate the password.
	hashPassword := XORHashAndSalt(entry.ScramblePassword, salt)
	if MatchSourceHost(remoteAddr, entry.SourceHost) && subtle.ConstantTimeCompare(authResponse, hashPassword) == 1 {
		return &StaticUserData{entry.UserData, entry.Groups}, AuthAccepted, nil
	}
	return &StaticUserData{}, AuthRejected, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}
func (a *AuthServerMysqlBase) UserEntryWithFullAuth(conn *Conn, salt []byte, user string, password string, remoteAddr net.Addr) (Getter, error) {
	a.mu.Lock()
	entries, ok := a.entries[user]
	a.mu.Unlock()
	if !ok {
		return &StaticUserData{}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
	}
	for _, entry := range entries {
		// Validate the password.
		pwhash, _ := ScrambleSha2Password(password, []byte(entry.MysqlCachingSha2Password))
		if MatchSourceHost(remoteAddr, entry.SourceHost) && subtle.ConstantTimeCompare([]byte(pwhash), []byte(entry.MysqlCachingSha2Password)) == 1 {
			entry.ScramblePassword = ScramblePassword([]byte(password))
			a.addUserToCache(user, entry)
			return &StaticUserData{entry.UserData, entry.Groups}, nil
		}
	}
	return &StaticUserData{}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}

// UserEntryWithHash implements password lookup based on a
// mysql_native_password hash that is negotiated with the client.
func (a *AuthServerMysqlBase) UserEntryWithHash(conn *Conn, salt []byte, user string, authResponse []byte, remoteAddr net.Addr) (Getter, error) {
	a.mu.Lock()
	entries, ok := a.entries[user]
	a.mu.Unlock()

	if !ok {
		return &StaticUserData{}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
	}

	for _, entry := range entries {
		if entry.MysqlNativePassword != "" {
			hash, err := DecodeMysqlNativePasswordHex(entry.MysqlNativePassword)
			if err != nil {
				return &StaticUserData{entry.UserData, entry.Groups}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
			}

			isPass := VerifyHashedMysqlNativePassword(authResponse, salt, hash)
			if MatchSourceHost(remoteAddr, entry.SourceHost) && isPass {
				return &StaticUserData{entry.UserData, entry.Groups}, nil
			}
		} else {
			computedAuthResponse := ScrambleMysqlNativePassword(salt, []byte(entry.Password))
			// Validate the password.
			if MatchSourceHost(remoteAddr, entry.SourceHost) && subtle.ConstantTimeCompare(authResponse, computedAuthResponse) == 1 {
				return &StaticUserData{entry.UserData, entry.Groups}, nil
			}
		}
	}
	return &StaticUserData{}, NewSQLError(ERAccessDeniedError, SSAccessDeniedError, "Access denied for user '%v'", user)
}

// NewHashPassword creates a new password for caching_sha2_password
func NewHashPassword(pwd string, pwhash string) string {
	pwHash, _ := ScrambleSha2Password(pwd, []byte(pwhash))
	return pwHash
}
