/*
Copyright ApeCloud, Inc.
Licensed under the Apache v2(found in the LICENSE file in the root directory).
*/

/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
WeSQL-Server db interface.
*/

package db

import (
	"errors"
	"sync"

	"github.com/spf13/pflag"

	"github.com/wesql/wescale/go/vt/external/golib/sqlutils"
	"github.com/wesql/wescale/go/vt/log"
	"github.com/wesql/wescale/go/vt/servenv"
	"github.com/wesql/wescale/go/vt/vtconsensus/config"
	"github.com/wesql/wescale/go/vt/vtconsensus/inst"
)

var (
	configFilePath string
	dbUser         string
	dbPasswd       string
	// ErrInvalidInstance is the error when the instance key has empty hostname
	ErrInvalidInstance = errors.New("invalid mysql instance key")
)

func init() {
	servenv.OnParseFor("vtconsensus", func(fs *pflag.FlagSet) {
		fs.StringVar(&configFilePath, "db_config", "", "Full path to db config file that will be used by VTConsensus.")
		fs.StringVar(&dbUser, "db_username", "root", "WeSQL-Server access username, --db_username, default root.")
		fs.StringVar(&dbPasswd, "db_password", "", "WeSQL-Server access password, --db_passwd, default empty.")
	})
}

// Agent is used by vtconsensus to interact with Mysql
type Agent interface {
	NewConsensusGlobalView() *ConsensusGlobalView
	// FetchConsensusLocalView fetches consensus local view related information
	FetchConsensusLocalView(alias string, instanceKey *inst.InstanceKey,
		globalView *ConsensusGlobalView) (*ConsensusLocalView, error)
	// FetchConsensusGlobalView fetches consensus global view
	FetchConsensusGlobalView(globalView *ConsensusGlobalView) error
}

// MemberRole is member role
type MemberRole int

const (
	UNKNOWNROLE MemberRole = iota
	SECONDARY              // wesql-server follower role is SECONDARY
	PRIMARY                // wesql-server leader role is PRIMARY
)

type ConsensusRole int

// TODO: wesqlscale support more wesql-server roles in the future.
const (
	UNKNOWNCONSENSUSROLE ConsensusRole = iota
	FOLLOWER
	LEADER
	LOGGER
	LEARNER
	CANDIDATE
)

// ConsensusLocalView represents a view we get from information_schema.wesql_cluster_local
type ConsensusLocalView struct {
	TabletAlias    string
	ServerID       int
	CurrentTerm    int
	CurrentLeader  string
	LeaderHostName string // LeaderHostName is from wesql_cluster_local.leader_host
	LeaderHostPort int    // LeaderHostPort is from wesql_cluster_local.leader_port
	Role           ConsensusRole
	IsRW           int
	// above field from information_schema.wesql_cluster_local
	TabletMySQLHost string // MySQLHost is from tablet.MysqlHostname
	TabletMySQLPort int    // MySQLPort is from tablet.MysqlPort
}

// ConsensusMember is instance info by wesql_cluster_global and wesql_cluster_local
// Note: ConsensusMember.MySQLHost and ConsensusLocalView.TabletMySQLHost are different.
// ConsensusMember.MySQLHost is used for consensus communication between nodes and is
// initialized from the cluster-info startup parameter of wesql-server.
// On the other hand, ConsensusLocalView.TabletMySQLHost is initialized
// from the db_host startup parameter of vttablet, which can be used for cross-pod access.
// For example, vtgate、vtconsensus、and vtctld can access the wesql-server instance through TabletMySQLHost.
type ConsensusMember struct {
	ServerID       int
	MySQLHost      string // MySQLHost is from wesql-server wesql_cluster_global.host.
	MySQLPort      int    // MySQLPort is from wesql-server wesql_cluster_global.port.
	Role           ConsensusRole
	ForceSync      int
	ElectionWeight int
	LearnerSource  string
	Connected      bool
}

// tablet.MysqlHostname and tablet.MysqlPort are initialized by vttablet running options.
// tablet.MysqlHostname and tablet.MysqlPort are used for connecting to mysql across pod.

// ConsensusGlobalView is an instance's view for the wesql-server information_schema.wesql_cluster_global
type ConsensusGlobalView struct {
	LeaderTabletMySQLHost string // LeaderMySQLHost is tablet.MysqlHostname, initialized by vttablet running option "--db_host".
	LeaderTabletMySQLPort int    // LeaderMySQLPort is tablet.MysqlPort, initialized by vttablet running options "--db_port".
	LeaderServerID        int
	// TODO: Currently not used, just recording information from wesql_cluster_global.
	ResolvedMember map[inst.InstanceKey]ConsensusMember // inst.InstanceKey is generated by tablet.MysqlHostname and tablet.MysqlPort.
	LocalView      []*ConsensusLocalView
	sync.Mutex
}

// SQLAgentImpl implements Agent
type SQLAgentImpl struct {
	config     *config.Configuration
	dbUserName string
	dbPassword string
}

func newConsensusLocalView(tabletAlias string, serverID int, currentTerm int, currentLeader string,
	leaderHostName string, leaderHostPort int, mySQLHost string,
	mySQLPort int, role ConsensusRole, isRW int) *ConsensusLocalView {
	return &ConsensusLocalView{TabletAlias: tabletAlias, ServerID: serverID,
		CurrentTerm: currentTerm, CurrentLeader: currentLeader, LeaderHostName: leaderHostName,
		LeaderHostPort: leaderHostPort, TabletMySQLHost: mySQLHost, TabletMySQLPort: mySQLPort,
		Role: role, IsRW: isRW}
}

func newConsensusMember(serverID int, mySQLHost string,
	mySQLPort int, role ConsensusRole, forceSync int, electionWeight int,
	learnerSource string, connected bool) *ConsensusMember {
	return &ConsensusMember{ServerID: serverID, MySQLHost: mySQLHost,
		MySQLPort: mySQLPort, Role: role, ForceSync: forceSync,
		ElectionWeight: electionWeight, LearnerSource: learnerSource, Connected: connected}
}

// NewConsensusGlobalView creates a new ConsensusGlobalView
func (agent *SQLAgentImpl) NewConsensusGlobalView() *ConsensusGlobalView {
	return &ConsensusGlobalView{}
}

// NewVTConsensusSQLAgent creates a SQLAgentImpl
func NewVTConsensusSQLAgent() *SQLAgentImpl {
	var conf *config.Configuration
	if (configFilePath) != "" {
		log.Infof("use config from %v", configFilePath)
		conf = config.ForceRead(configFilePath)
	} else {
		log.Warningf("use default config")
		conf = config.Config
	}
	agent := &SQLAgentImpl{
		config:     conf,
		dbUserName: dbUser,
		dbPassword: dbPasswd,
	}
	return agent
}

// FetchConsensusLocalView implements Agent interface
func (agent *SQLAgentImpl) FetchConsensusLocalView(alias string, instanceKey *inst.InstanceKey,
	globalView *ConsensusGlobalView) (*ConsensusLocalView, error) {
	var leaderHostname string
	var leaderHostPort int
	var localView *ConsensusLocalView

	// TODO: This leader_port is actually using the current instance's port because it is not possible to obtain this information.
	query := `select server_id, current_term, current_leader, 
        left(current_leader, locate(':', current_leader) -1) as leader_hostname, 
    	@@port as leader_port, 
    	case role when 'Leader' then 2 when 'Follower' then 1 else 0 end as role, 
        case server_ready_for_rw when 'NO' then 0  when 'YES' then 1 end as isrw 
	from information_schema.wesql_cluster_local;`

	err := fetchInstance(instanceKey, query, agent.dbUserName, agent.dbPassword, func(m sqlutils.RowMap) error {
		leaderHostname = m.GetString("leader_hostname")
		leaderHostPort = m.GetInt("leader_port")
		localView = newConsensusLocalView(
			alias,
			m.GetInt("server_id"),
			m.GetInt("current_term"),
			m.GetString("current_leader"),
			leaderHostname,
			leaderHostPort,
			instanceKey.Hostname,
			instanceKey.Port,
			ConsensusRole(m.GetInt("role")),
			m.GetInt("isrw"))
		globalView.Lock()
		defer globalView.Unlock()
		globalView.LocalView = append(globalView.LocalView, localView)
		return nil
	})
	if err != nil {
		return nil, err
	}
	return localView, nil
}

// FetchConsensusGlobalView returns the view of wesql_cluster_global
func (agent *SQLAgentImpl) FetchConsensusGlobalView(globalView *ConsensusGlobalView) error {
	query := `select g.server_id,          
    left(g.ip_port, locate(':', g.ip_port) -1) as hostname,      
    @@port as port,     case g.role when 'Leader' then 2 when 'Follower' then 1 else 0 end as role,     
    case force_sync when 'YES' then 1 when 'NO' then 0 end as force_sync,      
    election_weight,learner_source, 
    case connected when 'YES' then true when 'NO' then false end as connected
    from information_schema.wesql_cluster_global g, information_schema.wesql_cluster_health h 
    where g.server_id = h.server_id;`

	if globalView.LeaderTabletMySQLHost == "" || globalView.LeaderTabletMySQLPort == 0 {
		return nil
	}
	leaderInstance := inst.InstanceKey{
		Hostname: globalView.LeaderTabletMySQLHost,
		Port:     globalView.LeaderTabletMySQLPort,
	}
	mk := make(map[inst.InstanceKey]ConsensusMember)

	err := fetchInstance(&leaderInstance, query, agent.dbUserName, agent.dbPassword, func(m sqlutils.RowMap) error {
		var tabletMySQLHost string
		var tabletMySQLPort int
		hostName := m.GetString("hostname")
		hostPort := m.GetInt("port")
		serverID := m.GetInt("server_id")

		// Can refer to the following ConsensusMember struct comment.
		for _, lv := range globalView.LocalView {
			if lv.ServerID == serverID {
				tabletMySQLHost = lv.TabletMySQLHost
				tabletMySQLPort = lv.TabletMySQLPort
				break
			}
		}
		consensusMember := newConsensusMember(
			m.GetInt("server_id"),
			hostName,
			hostPort,
			ConsensusRole(m.GetInt("role")),
			m.GetInt("force_sync"),
			m.GetInt("election_weight"),
			m.GetString("learner_source"),
			m.GetBool("connected"))
		curInstance := inst.InstanceKey{
			Hostname: tabletMySQLHost,
			Port:     tabletMySQLPort,
		}
		mk[curInstance] = *consensusMember
		return nil
	})
	if err != nil {
		return err
	}
	globalView.ResolvedMember = mk
	return nil
}

// fetchInstance fetches result from mysql
func fetchInstance(instanceKey *inst.InstanceKey, query string, userName string, passwd string, onRow func(sqlutils.RowMap) error) error {
	if err := verifyInstance(instanceKey); err != nil {
		return err
	}
	sqlDb, err := OpenDiscovery(instanceKey.Hostname, instanceKey.Port, userName, passwd)
	if err != nil {
		return err
	}
	return sqlutils.QueryRowsMap(sqlDb, query, onRow)
}

// The hostname and port can be empty if a tablet crashed and did not populate them in
// the topo server. We treat them as if the host is unreachable when we calculate the
// quorum for the shard.
func verifyInstance(instanceKey *inst.InstanceKey) error {
	if instanceKey.Hostname == "" || instanceKey.Port == 0 {
		return ErrInvalidInstance
	}
	return nil
}
